\documentclass{article}
\usepackage{graphicx}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{tikz}
\usepackage{url}
\usepackage{listings}
  \usepackage{courier}
 \lstset{
         basicstyle=\footnotesize\ttfamily, % Standardschrift
         %numbers=left,               % Ort der Zeilennummern
         numberstyle=\tiny,          % Stil der Zeilennummern
         %stepnumber=2,               % Abstand zwischen den Zeilennummern
         numbersep=5pt,              % Abstand der Nummern zum Text
         tabsize=2,                  % Groesse von Tabs
         extendedchars=true,         %
         breaklines=true,            % Zeilen werden Umgebrochen
         keywordstyle=\color{red},
    		frame=b,         
 %        keywordstyle=[1]\textbf,    % Stil der Keywords
 %        keywordstyle=[2]\textbf,    %
 %        keywordstyle=[3]\textbf,    %
 %        keywordstyle=[4]\textbf,   \sqrt{\sqrt{}} %
         stringstyle=\color{white}\ttfamily, % Farbe der String
         showspaces=false,           % Leerzeichen anzeigen ?
         showtabs=false,             % Tabs anzeigen ?
         xleftmargin=17pt,
         framexleftmargin=17pt,
         framexrightmargin=5pt,
         framexbottommargin=4pt,
         %backgroundcolor=\color{lightgray},
         showstringspaces=false      % Leerzeichen in Strings anzeigen ?        
 }
 \lstloadlanguages{% Check Dokumentation for further languages ...
         %[Visual]Basic
         %Pascal
         %C
         %C++
         %XML
         %HTML
         Java
 }
    %\DeclareCaptionFont{blue}{\color{blue}} 

  %\captionsetup[lstlisting]{singlelinecheck=false, labelfont={blue}, textfont={blue}}
  \usepackage{caption}
\DeclareCaptionFont{white}{\color{white}}
\DeclareCaptionFormat{listing}{\colorbox[cmyk]{0.43, 0.35, 0.35,0.01}{\parbox{\textwidth}{\hspace{15pt}#1#2#3}}}
\captionsetup[lstlisting]{format=listing,labelfont=white,textfont=white, singlelinecheck=false, margin=0pt, font={bf,footnotesize}}
\usepackage{savetrees}
\usetikzlibrary{shapes}


\linespread{1.4}

\title{Homework - 2}

\author{\\
        Aniruddha Laud (107635282)\\
        Gaurav Menghani (108266803)\\
        Madhava Keralapura (107710538)\\}



\begin{document}

\maketitle

\clearpage

\tableofcontents

\clearpage

\section{Rabin Karp}
We performed Rabin-Karp randomized string matching algorithm on a set of strings of various sizes and with different number of unique characters. We performed experiments with 3 batches. For each batch, we fixed the size of the haystack and the needle. Then we generated multiple sets in each batch where each set numbered $i$ contained the first $i$ characters of the alphabet ($a$ - $z$). We then generated a set of primes. We used all primes less than 100 and all primes in the range 2100 - 2200. Between 100 and 2100, we used every $10^{th}$ prime. The base while running the Rabin-Karp algorithm for any set was 26 and the alphabet $a$ had a value of 1, $b$ a value of 2 and so on. \\

Let us define the smallest prime that gives similar timing performance as a large prime as the `tipping point'.
The first set had haystack length of 100000 and needles of size 50000. In this set, we found that the tipping point was somewhere in the range of 15 to 60. It varied based on the number of unique characters in the string. The more the number of unique characters, the higher the tipping point. \\

In the second set, the haystack had a length of 1000000 and the needles were of length 100000. We carried out this experiments only for up to 8 unique characters. The tipping point was in the range of 75-100 consistently till the 8th set. We also did an experiement with 26 unique characters and the tipping point was around 125. This made it clear that the tipping point increased as the number of unique characters in the haystack increased. 
For the third set, the haystack was set at 1000000, but the length of each needle was now 500000. The tipping point increased in this case to somewhere in the range of 450 to 625 based on the number of unique characters. Here again, we had 8 sets of data. \\

So, we saw that the tipping point was a function of a number of factors such as the length of the needles, the haystack and the number of unique characters in the haystack and needles. \\

\clearpage
\lstinputlisting[label=samplecode,caption=Source Code for the Rabin Karp problem]{problem1/p1.cpp}
\clearpage

\clearpage

\section{Smith Waterman}
\clearpage

\section{Open Reading Frames}
Open Reading Frames in a DNA sequence are sequences of codons, separated by a starting and stopping codon pair. Using the program listed later, we analysed Viral, Bacterial, Human and Random DNA sequences. We had roughly 6 MB of genomic data in FASTA files for Bacterial, Human and Random DNA sequences, and 1 MB of genomic data for Viral DNA. So its easy to compare amongst them.

The histogram for the ORFs in viral genomes is below. It was easy to see that there are few long ORFs, but the number of ORFs of length in the range 200-550 remains roughly constant.

\begin{figure}[htp]
\centering
\includegraphics[scale=0.5]{viral_genome.png}
\caption{Histogram of Viral Genome ORF length v/s Frequencies}\label{fig:fs}
\end{figure}

\clearpage

The histogram for the ORFs in bacterial genomes is below. Contrast the histogram with the histogram of human genomic data. While the peak of this histogram is smaller, but the number of ORFs of lengths in the region 300-700 are significant as compared to human genome, where it steeply drops to nearly zero in that range.
\begin{figure}[htp]
\centering
\includegraphics[scale=0.4]{bacterial_genome.png}
\caption{Histogram of Bacterial Genome ORF length v/s Frequencies}\label{fig:fs}
\end{figure}


The histogram below shows a distinct difference from viral and bacterial genomes. There are fewer ORFs of lengths longer than 300, but more ORFs of around 100-150 codons.
\begin{figure}[htp]
\centering
\includegraphics[scale=0.5]{human_genome.png}
\caption{Histogram of Human Genome ORF length v/s Frequencies}\label{fig:fs}
\end{figure}
\clearpage
The histogram below is for a Random DNA sequence, which was about the same size as the human and bacterial genome data. However, a clear distinction is that there are no ORFs of length more than 250 codons, and the number of ORFs with length greater than 100 decreases extremely steeply. This is inline with our expectations.

\begin{figure}[htp]
\centering
\includegraphics[scale=0.5]{random_sequence.png}
\caption{Histogram of Random DNA sequence ORF length v/s Frequencies}\label{fig:fs}
\end{figure}


\clearpage

\lstinputlisting[label=samplecode,caption=Source Code for the Open Reading Frames problem]{problem3.py}
\clearpage

 
\clearpage

\section{Shortest non-contiguous supersequence of two strings Problem}
This problem is solved using Dynamic Programming. Let $n$ and $m$ be the lengths of the two strings, $a$ and $b$ respectively, and $i$ and $j$ be the pointers in the strings. The problem is to find the shortest non-contiguous super-sequence of the two strings from $(i..n-1)$ and $(j..m-1)$. This problem can be solved by solving its sub-problems of getting super-sequences for smaller strings:
\begin{enumerate}
\item If $a[i]$ == $b[j]$, then both the characters overlap in the super-sequence, and the length of the supersequence is 1 + length of shortest non-contiguous super-sequnce for the two strings from $(i+1..n-1)$ and $(j+1..m-1)$
\item The character $a[i]$ is in the supersequence, and the length of the supersequence is 1 + length of shortest non-contiguous super-sequnce for the two strings from $(i+1..n-1)$ and $(j..m-1)$
\item The character $b[j]$ is in the supersequence, and the length of the supersequence is 1 + length of shortest non-contiguous super-sequnce for the two strings from $(i..n-1)$ and $(j+1..m-1)$
\end{enumerate}

If $i = n-1$, and $j < m-1$, then all the remaining characters in $b$ would be inserted in the super-sequence. Similarly, if $j = m-1$, and $i < n-1$, then all the remaining characters in $a$ would be inserted in the super-sequence.
\\
Thus, the DP table is $n$x$n$, and hence the space complexity is $O(n^2)$. Since, there are $n^2$ cells, one for each problem, and we can solve it using the results of its sub-problems in constant time, filling each cell requires constant time. Overall, filling the DP table requires $O(n^2)$ time. 

The code for the solution is as follows:
\lstinputlisting[label=samplecode,caption=Dynamic Programming solution for the problem]{problem_4_snippet.cpp}
\clearpage

\section{Minimum Length Palindrome Problem}
This problem is solved using Dynamic Programming. Let $i$ and $j$ be the pointers to the starting position in the string and the ending position in the string. The problem is to find the minimum length palindrome of the string between $i$ and $j$. Now, if the characters, $str[i]$ and $str[j]$ don't match, we have two options:
\begin{enumerate} 
\item Insert the character $str[i]$ before the position $j$, at the cost of one character, and solve the problem for the string between $i+1$ and $j$.
\item Insert the character $str[j]$ before the position $i$, at the cost of one character, and solve the problem for the string between $i$ and $j+1$.
\end{enumerate}
If $str[i]$ and $str[j]$ match, we simply solve the sub-problem for the string between $i+1$ and $j-1$.
The cost of solving the smallest sub-problem problem for the string between $i$ and $i$, is obviously 0, since the string has only one character in it. Thus, the DP table is $n$x$n$, and hence the space complexity is $O(n^2)$. Since, there are $n^2$ cells, one for each problem, and we can solve it using the results of its sub-problems in constant time, filling each cell requires constant time. Overall, filling the DP table requires $O(n^2)$ time. 

The code for the solution is as follows:
\lstinputlisting[label=samplecode,caption=Dynamic Programming solution for the problem]{problem_5_snippet.cpp}
\clearpage

\section{Pizza Picking Problem}
In this problem, we again use the Dynamic Programming approach. The constraint of the problem is such, that at any given time the gaps in the pizza pie would be contiguous. If there are $n$ slices in the pizza, picking any slice as the pivot, we start numbering each slice from $0$ to $n-1$ in clockwise order. Now, when Alice and Bob start picking slices, there would be only one contiguous gap in the pizza pie. This gap can be described by two indices, $i$ and $j$, the first missing slice and the last missing slice, in clockwise order. We solve the problem from Alice's perspective, and hence when we have a pizza with a contiguous gap from $i$ and $j$, the problem is to maximize the total area of pizza slices that Alice gets.

If we know $i$, $j$ and whose turn it is to take the next slice, we move ahead by taking a pizza from either of the ends, adding the slice area to alice's account if it was alice's turn, and then solving the subproblem of picking slices from the remaining pizza, and allowing the other person to pick a slice this time. In Alice's turn, Alice chooses the slice which maximizes the result, whereas in Bob's turn, Bob chooses the slice, which minimizes the result (remember, the result is the maximum area of the pizza that Alice consumes, so Bob, playing optimally, would obviously try to minimize this). 

Hence the state of the Dynamic Programming solution is $i$, $j$, and $turn$. $turn$ is 1, when its Alice's turn to pick a slice, and 0 when its not. Thus the DP table would be of size $n.n.2$, which is $O(n^2)$ space complexity. From one problem, we can reach to a sub-problem in constant time, and thus each cell in the table would be filled in constant time. Since there are at most $n^2$ cells in the DP, it takes $O(n^2)$ time.

The code for the solution is as follows:
\lstinputlisting[label=samplecode,caption=Dynamic Programming solution for the problem]{problem_6_snippet.cpp}

\end{document}
